package opencode

import (
	"fmt"
	"os"
	"path/filepath"
)

// pluginTemplate is the JavaScript plugin that hooks into OpenCode's
// tool execution hooks and calls shiftlog store after git commits.
//
// OpenCode plugin hooks:
//   tool.execute.before(input, output) — input: {tool, sessionID, callID}, output: {args}
//   tool.execute.after(input, output)  — input: {tool, sessionID, callID}, output: {title, output, metadata}
//
// The command string is only available in the "before" hook (via output.args),
// so we capture it there and act on it in the "after" hook, matching by callID.
const pluginTemplate = `// shiftlog plugin for OpenCode CLI
// Auto-generated by shiftlog init --agent=opencode
// Do not edit manually - re-run 'shiftlog init --agent=opencode' to update

export const ClauditPlugin = async ({ directory, client }) => {
  const pendingCommits = new Map();

  return {
    "tool.execute.before": async (input, output) => {
      const command = output?.args?.command || output?.args?.cmd || "";
      if (command.includes("git commit") || command.includes("git-commit")) {
        pendingCommits.set(input.callID, {
          command,
          tool: input.tool,
          sessionID: input.sessionID,
        });
      }
    },

    "tool.execute.after": async (input, output) => {
      const pending = pendingCommits.get(input.callID);
      if (!pending) return;
      pendingCommits.delete(input.callID);

      // Try to fetch messages via the SDK client API
      let transcriptData = "";
      if (client && pending.sessionID) {
        try {
          const msgs = await client.session.messages({ path: { id: pending.sessionID } });
          if (msgs && Array.isArray(msgs)) {
            transcriptData = JSON.stringify(msgs.map(m => ({
              role: m.role || "",
              id: m.id || "",
              content: m.content || "",
              time: m.time || {},
            })));
          }
        } catch (e) {
          // Fall back to data_dir approach below
        }
      }

      const dataDir = process.platform === "darwin"
          ? process.env.HOME + "/Library/Application Support/opencode"
          : (process.env.XDG_DATA_HOME || process.env.HOME + "/.local/share") + "/opencode";

      const hookData = JSON.stringify({
        session_id: pending.sessionID || "",
        data_dir: dataDir,
        project_dir: directory,
        tool_name: pending.tool || "",
        tool_input: { command: pending.command },
        ...(transcriptData ? { transcript_data: transcriptData } : {}),
      });

      try {
        const { execSync } = await import("child_process");
        execSync("shiftlog store --agent=opencode", {
          input: hookData,
          cwd: directory,
          timeout: 30000,
          stdio: ["pipe", "pipe", "pipe"],
        });
      } catch (e) {
        // Silently ignore errors to not disrupt workflow
      }
    },
  };
};
`

// InstallPlugin writes the shiftlog plugin to .opencode/plugins/shiftlog.js.
func InstallPlugin(repoRoot string) error {
	pluginDir := filepath.Join(repoRoot, ".opencode", "plugins")
	if err := os.MkdirAll(pluginDir, 0755); err != nil {
		return fmt.Errorf("could not create plugin directory: %w", err)
	}

	pluginPath := filepath.Join(pluginDir, "shiftlog.js")
	if err := os.WriteFile(pluginPath, []byte(pluginTemplate), 0644); err != nil {
		return fmt.Errorf("could not write plugin file: %w", err)
	}

	return nil
}

// RemovePlugin removes the shiftlog plugin file.
// Also removes the plugins directory if it's empty afterward.
func RemovePlugin(repoRoot string) error {
	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", "shiftlog.js")
	if err := os.Remove(pluginPath); err != nil && !os.IsNotExist(err) {
		return err
	}

	// Remove plugins dir if empty
	pluginDir := filepath.Join(repoRoot, ".opencode", "plugins")
	entries, err := os.ReadDir(pluginDir)
	if err == nil && len(entries) == 0 {
		_ = os.Remove(pluginDir)
	}

	return nil
}

// HasPlugin checks if the shiftlog plugin is installed.
func HasPlugin(repoRoot string) bool {
	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", "shiftlog.js")
	_, err := os.Stat(pluginPath)
	return err == nil
}
