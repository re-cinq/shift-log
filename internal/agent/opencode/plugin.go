package opencode

import (
	"fmt"
	"os"
	"path/filepath"
)

// pluginTemplate is the JavaScript plugin that hooks into OpenCode's
// tool execution hooks and calls claudit store after git commits.
//
// OpenCode plugin hooks:
//   tool.execute.before(input, output) — input: {tool, sessionID, callID}, output: {args}
//   tool.execute.after(input, output)  — input: {tool, sessionID, callID}, output: {title, output, metadata}
//
// The command string is only available in the "before" hook (via output.args),
// so we capture it there and act on it in the "after" hook, matching by callID.
const pluginTemplate = `// claudit plugin for OpenCode CLI
// Auto-generated by claudit init --agent=opencode
// Do not edit manually - re-run 'claudit init --agent=opencode' to update

export const ClauditPlugin = async ({ directory }) => {
  const pendingCommits = new Map();

  return {
    "tool.execute.before": async (input, output) => {
      const command = output?.args?.command || output?.args?.cmd || "";
      if (command.includes("git commit") || command.includes("git-commit")) {
        pendingCommits.set(input.callID, {
          command,
          tool: input.tool,
          sessionID: input.sessionID,
        });
      }
    },

    "tool.execute.after": async (input, output) => {
      const pending = pendingCommits.get(input.callID);
      if (!pending) return;
      pendingCommits.delete(input.callID);

      const dataDir = process.platform === "darwin"
          ? process.env.HOME + "/Library/Application Support/opencode"
          : (process.env.XDG_DATA_HOME || process.env.HOME + "/.local/share") + "/opencode";

      const hookData = JSON.stringify({
        session_id: pending.sessionID || "",
        data_dir: dataDir,
        project_dir: directory,
        tool_name: pending.tool || "",
        tool_input: { command: pending.command },
      });

      try {
        const { execSync } = await import("child_process");
        execSync("claudit store --agent=opencode", {
          input: hookData,
          cwd: directory,
          timeout: 30000,
          stdio: ["pipe", "pipe", "pipe"],
        });
      } catch (e) {
        // Silently ignore errors to not disrupt workflow
      }
    },
  };
};
`

// InstallPlugin writes the claudit plugin to .opencode/plugins/claudit.js.
func InstallPlugin(repoRoot string) error {
	pluginDir := filepath.Join(repoRoot, ".opencode", "plugins")
	if err := os.MkdirAll(pluginDir, 0755); err != nil {
		return fmt.Errorf("could not create plugin directory: %w", err)
	}

	pluginPath := filepath.Join(pluginDir, "claudit.js")
	if err := os.WriteFile(pluginPath, []byte(pluginTemplate), 0644); err != nil {
		return fmt.Errorf("could not write plugin file: %w", err)
	}

	return nil
}

// HasPlugin checks if the claudit plugin is installed.
func HasPlugin(repoRoot string) bool {
	pluginPath := filepath.Join(repoRoot, ".opencode", "plugins", "claudit.js")
	_, err := os.Stat(pluginPath)
	return err == nil
}
